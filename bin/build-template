#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Rails Template Builder â€” Orchestrates pi agents for each phase
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# Usage:
#   ./bin/build-template           # Run all phases from the start
#   ./bin/build-template 05        # Resume from Phase 05
#   ./bin/build-template 05 07     # Run only Phases 05 through 07
#
# Environment:
#   PI_MODEL    â€” Override the model (default: claude-sonnet-4-5)
#   PI_PROVIDER â€” Override the provider (default: anthropic)
#   MAX_RETRIES â€” Override max retries per phase (default: 3)

PHASES=(01 02 03 04 05 06 07 08 09 10 11 12 13)
MAX_RETRIES="${MAX_RETRIES:-3}"
PI_MODEL="${PI_MODEL:-claude-sonnet-4-5}"
PI_PROVIDER="${PI_PROVIDER:-anthropic}"
PROJECT_DIR="$(cd "$(dirname "$0")/.." && pwd)"
LOG_FILE="$PROJECT_DIR/build.log"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
BOLD='\033[1m'
RESET='\033[0m'

log()      { echo -e "$(date '+%H:%M:%S') ${BLUE}[META]${RESET} $*" | tee -a "$LOG_FILE"; }
log_ok()   { echo -e "$(date '+%H:%M:%S') ${GREEN}[META]${RESET} $*" | tee -a "$LOG_FILE"; }
log_warn() { echo -e "$(date '+%H:%M:%S') ${YELLOW}[META]${RESET} $*" | tee -a "$LOG_FILE"; }
log_err()  { echo -e "$(date '+%H:%M:%S') ${RED}[META]${RESET} $*" | tee -a "$LOG_FILE"; }

# â”€â”€â”€ Pre-flight checks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
preflight() {
  log "Running pre-flight checks..."
  cd "$PROJECT_DIR"

  if ! command -v pi &>/dev/null; then
    log_err "pi not found. Install: npm install -g @mariozechner/pi-coding-agent"
    exit 1
  fi

  if ! command -v rails &>/dev/null; then
    log_err "rails not found. Install Ruby and Rails first."
    exit 1
  fi

  if ! command -v git &>/dev/null; then
    log_err "git not found."
    exit 1
  fi

  # If git repo exists, check for clean state
  if [ -d ".git" ]; then
    if [ -n "$(git status --porcelain)" ]; then
      log_warn "Git working tree is dirty. Committing current state before starting..."
      git add -A
      git commit -m "Pre-build snapshot" --allow-empty
    fi
  fi

  log_ok "Pre-flight OK (pi $(pi --version), rails $(rails --version | awk '{print $2}'))"
}

# â”€â”€â”€ Verification: check that a phase's output is healthy â”€â”€â”€â”€â”€
verify_phase() {
  local phase="$1"
  local errors=""

  cd "$PROJECT_DIR"

  # Phase 01 just needs the app to boot
  if [ "$phase" == "01" ]; then
    if [ ! -f "Gemfile" ]; then
      errors+="No Gemfile found â€” rails app not created. "
    elif ! bin/rails runner "puts 'OK'" 2>&1; then
      errors+="Rails app won't boot. "
    fi

    if [ -n "$errors" ]; then
      echo "$errors"
      return 1
    fi
    return 0
  fi

  # All other phases: app must boot
  if ! bin/rails runner "puts 'OK'" 2>/dev/null; then
    errors+="Rails app won't boot. "
  fi

  # Tests must pass (allow no tests to count as passing)
  local test_output
  test_output=$(bin/rails test 2>&1) || {
    # Check if it's "0 tests, 0 failures" (which exits 0) vs actual failures
    if echo "$test_output" | grep -q "failures\|errors"; then
      errors+="Test failures: $(echo "$test_output" | tail -5) "
    fi
  }

  # Tailwind must build (Phase 02+)
  if [ "$phase" -ge 02 ] 2>/dev/null && [ -f "app/assets/tailwind/application.css" ]; then
    if ! bin/rails tailwindcss:build 2>/dev/null; then
      errors+="Tailwind build failed. "
    fi
  fi

  # Check for Ruby syntax errors in app code
  local syntax_errors
  syntax_errors=$(find app lib config -name "*.rb" -exec ruby -c {} \; 2>&1 | grep -v "Syntax OK" | head -10 || true)
  if [ -n "$syntax_errors" ]; then
    errors+="Ruby syntax errors: $syntax_errors "
  fi

  # Check for pending migrations
  if bin/rails db:migrate:status 2>/dev/null | grep -q "down"; then
    errors+="Pending migrations exist. "
  fi

  if [ -n "$errors" ]; then
    echo "$errors"
    return 1
  fi
  return 0
}

# â”€â”€â”€ Build the system prompt appendix â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
build_system_prompt() {
  local phase="$1"
  local attempt="$2"

  cat <<'PROMPT'
You are implementing a Rails 8 template project, one phase at a time. Critical rules:

1. Follow the plan file EXACTLY. Implement every step, every file, every command.
2. Do NOT leave TODOs, placeholders, or "implement this later" comments. Everything must be complete.
3. Do NOT skip steps because they seem optional. If the plan says to create it, create it.
4. After implementing, run the verification steps from the plan.
5. If a file already exists from a previous phase, modify it â€” don't overwrite unless the plan says to replace it.
6. Use `bin/rails` (not `rails`) for all Rails commands.
7. If a step references a model/class from a FUTURE phase, create a minimal skeleton so the current code works.
8. Run `bin/rails db:migrate` after creating migrations.
9. Run `bundle install` after modifying the Gemfile.
10. Ensure all files are saved and all commands have been executed before finishing.
PROMPT
}

# â”€â”€â”€ Run a single phase â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
run_phase() {
  local phase="$1"
  local plan_file
  plan_file=$(ls plans/${phase}-*.md 2>/dev/null | head -1)

  if [ -z "$plan_file" ]; then
    log_err "No plan file found for phase $phase"
    return 1
  fi

  local phase_name
  phase_name=$(basename "$plan_file" .md | sed 's/^[0-9]*-//')
  
  echo ""
  log "${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
  log "${BOLD}  PHASE $phase: $phase_name${RESET}"
  log "${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
  echo ""

  local attempt=0
  local success=false

  while [ $attempt -lt $MAX_RETRIES ]; do
    attempt=$((attempt + 1))
    log "Attempt $attempt/$MAX_RETRIES"

    local sys_prompt
    sys_prompt=$(build_system_prompt "$phase" "$attempt")

    if [ $attempt -eq 1 ]; then
      # â”€â”€ First attempt: implement from the plan â”€â”€
      log "Invoking pi to implement phase $phase..."
      
      pi -p \
        --provider "$PI_PROVIDER" \
        --model "$PI_MODEL" \
        --thinking high \
        --no-session \
        --append-system-prompt "$sys_prompt" \
        @"$plan_file" \
        @plans/00-overview.md \
        "Implement Phase $phase ($phase_name) completely. The full plan is in the attached file. Execute every step in order. Create all files listed in 'Files Created/Modified'. Run all shell commands. Then run the Verification checks." \
        2>&1 | tee -a "$LOG_FILE"
    else
      # â”€â”€ Retry: fix specific errors â”€â”€
      local error_output
      error_output=$(verify_phase "$phase" 2>&1 || true)

      log_warn "Retrying phase $phase â€” fixing errors..."
      
      pi -p \
        --provider "$PI_PROVIDER" \
        --model "$PI_MODEL" \
        --thinking high \
        --no-session \
        --append-system-prompt "$sys_prompt" \
        @"$plan_file" \
        "Phase $phase ($phase_name) was partially implemented but has errors. Fix them.

ERRORS FROM VERIFICATION:
$error_output

Steps:
1. Read the error messages carefully
2. Read the relevant source files to understand the current state
3. Make targeted fixes (don't rewrite everything)
4. Run the commands needed to verify the fix (e.g., bin/rails test, bin/rails db:migrate)
5. Confirm the errors are resolved" \
        2>&1 | tee -a "$LOG_FILE"
    fi

    # â”€â”€ Verify â”€â”€
    log "Verifying phase $phase..."
    local verify_result
    verify_result=$(verify_phase "$phase" 2>&1) && {
      success=true
      break
    } || {
      log_warn "Verification failed: $verify_result"
    }
  done

  # â”€â”€ Commit result â”€â”€
  if [ "$success" = true ]; then
    log_ok "âœ… Phase $phase ($phase_name) â€” PASSED"
    git add -A
    git commit -m "Phase $phase: $phase_name" --allow-empty
    return 0
  else
    log_err "âŒ Phase $phase ($phase_name) â€” FAILED after $MAX_RETRIES attempts"
    git add -A
    git commit -m "Phase $phase: $phase_name [NEEDS FIX]" --allow-empty
    return 1
  fi
}

# â”€â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
main() {
  local start_phase="${1:-01}"
  local end_phase="${2:-13}"
  
  preflight

  # Initialize git if needed
  if [ ! -d ".git" ]; then
    git init
    git add -A
    git commit -m "Initial commit: build plans" --allow-empty
    log "Initialized git repository"
  fi

  log "Building phases $start_phase through $end_phase"
  log "Model: $PI_PROVIDER/$PI_MODEL | Max retries: $MAX_RETRIES"
  log "Log file: $LOG_FILE"
  echo ""

  local started=false
  local failed=false

  for phase in "${PHASES[@]}"; do
    # Skip phases outside our range
    if [ "$started" = false ]; then
      if [ "$phase" = "$start_phase" ]; then
        started=true
      else
        continue
      fi
    fi

    # Stop if we've passed the end phase
    if [ "$phase" -gt "$end_phase" ] 2>/dev/null; then
      break
    fi

    if ! run_phase "$phase"; then
      log_err "Stopping at phase $phase."
      log_err "To fix manually and resume: ./bin/build-template $(printf '%02d' $((10#$phase)))"
      failed=true
      break
    fi
  done

  echo ""
  if [ "$failed" = false ]; then
    log_ok "ðŸŽ‰ ${BOLD}All phases complete!${RESET}"
    log "Review the git log:"
    git log --oneline | head -15
  fi
}

main "$@"
